
```javascript
[基本语法概念]

	: 基本语法 [语句、标识符(变量)、注释、区块、判断语句(条件语句、循环语句)]
  # 语句、表达式(expression)
  # 变量提升
  # 条件语句 - if 、if-else、switch、?:
  # 循环语句 - while、for、do-while、break & continue、label
  // var (变量的声明和赋值 (声明未赋值, 值为 undefined; 未声明直接使用, 报错))
  // 动态类型语言, 变量的类型没有限制, 变量可以随时更改类型。
  // - JavaScript 引擎的工作方式是, 先解析代码, 获取所有被声明的变量, 然后再一行一行地运行。
  // - 所以导致, 所有的变量的声明语句, 都会被提升到代码的头部, 这就叫做变量提升(hoisting)
  // 标识符(identifier) : 用来识别各种值的合法名称。最常见的标识符就是变量名, 以及函数名。
  // - JavaScript 语言的标识符对大小写敏感
  // 区块 (block) : 用大括号, 将多个相关的语句组合在一起
  // - 对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）
  // JS中, 区块往往用来构成其他更复杂的语法结构, 比如for、if、while、function等

  : 数据类型 (6+1)、数值、字符串、对象、数组、函数、数据类型转换、运算符
  # 数值 number | 字符串 string | 布尔值 boolean | 对象 object | Symbol
  # - 未定义或不存在 undefined  | 空值 null
  // - 原始类型 primitive type : 数值、字符串、布尔值, 最基本的数据类型
  // - 合成类型 complex type   : 对象, 其往往是多个原始类型的值的合成, 可以看作存放各种值的容器
  // - 特殊值 : undefined、null
  # 对象是最复杂的数据类型, 又可分成三个子类型 : 狭义对象 object、数组 array、函数 function
  # 强制转换 - Number()、String()、Boolean() | 原始类型值转换规则、对象类型值转换规则
  # 自动转换 - 不同类型的数据互相运算、非布尔值类型的数据求布尔值、非数值类型的值使用一元运算符
  // - 预期什么类型的值，就调用该类型的转换函数
  # 运算符 : 加法 | 算术 | 赋值
  # - 比较(字符串、非字符串、严格相等、相等) | 布尔(取反、且、或、三元条件)
  # - 位(二进制或、二进制与、二进制否、异或、左移、右移、带符号位的右移、开关作用)
  # - 其他 : void 运算符、逗号运算符
  # - 运算顺序(优先级、圆括号、左结合与右结合)
  // 运算符是处理数据的基本方法，用来从现有的值得到新的值

  : 错误处理机制、编程风格
  # JavaScript 解析或运行时, 一旦发生错误, 引擎就会抛出一个错误对象, 中断在发生错误的地方
  # 原生提供Error构造函数, 所有抛出的错误都是这个构造函数的实例
  # Error 属性 : message 错误提示信息 name 错误名称(非标准属性) stack 错误的堆栈 (非标准属性)
	# 派生对象 : SyntaxError | ReferenceError | RangeError | TypeError | URIError | EvalError
	# 自定义错误
  # throw 语句 - 抛出错误
  # try-catch-finally : 捕获处理错误

[基本对象与标准库]

	: Number对象、String对象、Object对象、Array对象

	: 属性描述对象、包装对象

  -> 进阶

  : Math对象

  : Date对象

  : RegExp对象

  : JSON对象

  : console对象

[面向对象编程]

	: this 关键字

  : prototype 对象

	: Object 对象与继承

[高级概念]

	: 异步操作概述

	: 定时器

  : Promise 对象

  : 严格模式

// 是什么 what、有何用途、功能 why、如何使用 how
```

### let & var & const

```javascript
[let]

	# ES6 新增, 用来声明变量, 所声明的变量, 只在let命令所在的代码块内有效
  // 不存在变量提升
  // 暂时性死区 (temporal dead zone, TDZ)
  // 不允许重复声明
  // 块级作用域 , ES5 只有全局作用域和函数作用域, ES6加入块级作用域(即, let和const声明的块)
  // 块级作用域的出现, 实际上使得获得广泛应用的匿名立即执行函数表达式(匿名 IIFE)不再必要了
// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
  
  # 块级作用域与函数声明
  // ES6 引入了块级作用域, 明确允许在块级作用域之中声明函数
  // 块级作用域之中, 函数声明语句的行为类似于let, 在块级作用域之外不可引用 (差异问题, 改成表达式)
  // ES6 的块级作用域必须有大括号, 如果没有大括号, JavaScript 引擎就认为不存在块级作用域。

[const]
  
	# 声明一个只读的常量, 一旦声明, 常量的值就不能改变
	// 不提升, 存在暂时性死区
	// 实际上保证的, 并不是变量的值不得改动, 而是变量指向的那个内存地址所保存的数据不得改动
	// 对象冻结, 应该使用Object.freeze方法

// 对象属性及其属性冻结 
var constantize = (obj) => {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) => {
    if ( typeof obj[key] === 'object' ) {
      constantize( obj[key] );
    }
  });
};

[ES6 声明变量的六种方法]
  
	# 顶层对象, 在浏览器环境指的是window对象, 在Node指的是global对象
	// ES5 之中，顶层对象的属性与全局变量是等价的
	// 顶层对象的属性与全局变量挂钩, 被认为是 JavaScript 语言最大的设计败笔之一
    
	# ES6, var命令和 function 命令声明的全局变量, 依旧是顶层对象的属性
	// let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性
	// 从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩
    
	# globalThis 对象
	// 垫片库global-this模拟了这个提案, 可以在所有环境拿到globalThis

[解构赋值]
  
	# 函数参数的解构赋值圆括号问题用途
  
  # 解构 Destructuring
  // ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值
  // 本质上, 这种写法属于“模式匹配”, 只要等号两边的模式相同, 左边的变量就会被赋予对应的值
  // 不完全解构, 即等号左边的模式, 只匹配一部分的等号右边的数组, 解构依然可以成功
  // 解构不成功, 变量的值就等于undefined
  // 解构赋值允许指定默认值
  
  # 数组的解构赋值
  // let [a, b, c] = [1, 2, 3]
  // 等号的右边不是数组(或者严格地说，不是可遍历的结构), 那么将会报错
  
  # 对象的解构赋值
  // let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
  // let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
  // 对象的属性没有次序, 变量必须与属性同名, 才能取到正确的值
  // 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量
  
  # 字符串的解构赋值
  // const [a, b, c, d, e] = 'hello';
  // 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值
  // let {length : len} = 'hello';
  // 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象
  
  # 数值和布尔值的解构赋值
  // 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象
  // 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象
  
  # 函数参数的解构赋值
  // 函数的参数也可以使用解构赋值 -> function add([x, y]){}
  
  # 圆括号问题
  // 解构赋值虽然很方便, 但是解析起来并不容易
  // 一个式子到底是模式, 还是表达式, 必须解析到(或解析不到)等号才能知道
  // 由此带来的问题是，如果模式中出现圆括号怎么处理。
  // ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号
  // 不能使用圆括号
  // - 变量声明语句
  // - 函数参数
  // - 赋值语句的模式
  
  # 用途
  // - 交换变量的值
  // - 从函数返回多个值
  // - 函数参数的定义
  // - 提取 JSON 数据
  // - 函数参数的默认值
  // - 遍历 Map 结构
  // - 输入模块的指定方法
```

