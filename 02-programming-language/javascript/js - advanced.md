
```javascript
[单线程模型]

	# js 只在一个线程上运行
  
[同步任务 synchronous]

	# 没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。

[异步任务 asynchronous]

	# 被引擎放在一边，不进入主线程、而进入任务队列的任务。

[任务队列 task queue & 事件循环 Event Loop]

	# 保存当前程序处理的异步任务
  // 主线程首先执行所有的同步任务, 执行完毕后, 查看任务队列里面的异步任务, 是否需要执行
  // 异步任务的写法通常是回调函数

[异步操作模式]

	# 回调函数
  // 优点是简单、容易理解和实现
  // 缺点是不利于代码的阅读和维护, 高度耦合, 程序结构混乱、流程难以追踪, 任务只能指定一个回调函数

  # 事件监听 (事件驱动模式)
  // 异步任务的执行不取决于代码的顺序, 而取决于某个事件是否发生
  // 优点是比较容易理解, 可以绑定多个事件, 每个事件可以指定多个回调函数, 去耦合, 有利于实现模块化
  // 缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程

	# 发布/订阅 (publish-subscribe pattern) (观察者模式 observer pattern)
  // 可以通过查看“消息中心”, 了解存在多少信号、每个信号有多少订阅者, 从而监控程序的运行

[异步操作流程控制]

	# 串行执行
  // 编写一个流程控制函数, 让它来控制异步任务, 一个任务完成以后, 再执行另一个
  
  # 并行执行
  // 并行的任务较多, 很容易耗尽系统资源, 拖慢运行速度
  
  # 并行与串行的结合
  // 设置一个门槛, 每次最多只能并行执行n个异步任务, 这样就避免了过分占用系统资源
```

```javascript
[定时器 Timer]

	# 定时执行代码的功能
  setTimeout()  指定某个函数或某段代码，在多少毫秒之后执行
  // 返回一个整数，表示定时器的编号，以后可以用来取消这个定时器
	setInterval() 指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行
  clearTimeout()  取消对应的定时器
	clearInterval() 取消对应的定时器
  
  # 防抖动 debounce
  
  # 调整事件的发生顺序, 推迟函数到下一次事件循环中执行
  
  # 运行机制
	// 将指定的代码移出本轮事件循环, 等到下一轮事件循环, 再检查是否到了指定时间, 进行执行

```

```javascript
[严格模式 ES5]

	# strict mode
  // 'use strict';
  // 严格模式可以用于整个脚本，也可以只用于单个函数
  
  # 严格显示报错
  // 只读属性不可写, 不可配置属性不可删除
  // 只设置了取值器的属性不可写
  // 禁止扩展的对象不可扩展
  // 函数不能有重名的参数
  // 全局变量显式声明
  // 禁止 this 关键字指向全局对象
  // 禁止使用 fn.callee、fn.caller
  
  // JS 的一个特点, 就是允许“动态绑定”,
  // 某些属性和方法到底属于哪一个对象, 不是在编译时确定的，而是在运行时（runtime）确定的

```

